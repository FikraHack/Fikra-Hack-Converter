//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//     Version du runtime :4.0.30319.42000
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Fikra_Hack_Converter.Properties {
    using System;
    
    
    /// <summary>
    ///   Une classe de ressource fortement typée destinée, entre autres, à la consultation des chaînes localisées.
    /// </summary>
    // Cette classe a été générée automatiquement par la classe StronglyTypedResourceBuilder
    // à l'aide d'un outil, tel que ResGen ou Visual Studio.
    // Pour ajouter ou supprimer un membre, modifiez votre fichier .ResX, puis réexécutez ResGen
    // avec l'option /str ou régénérez votre projet VS.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Retourne l'instance ResourceManager mise en cache utilisée par cette classe.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Fikra_Hack_Converter.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Remplace la propriété CurrentUICulture du thread actuel pour toutes
        ///   les recherches de ressources à l'aide de cette classe de ressource fortement typée.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Recherche une ressource localisée de type System.Drawing.Icon semblable à (Icône).
        /// </summary>
        internal static System.Drawing.Icon Application {
            get {
                object obj = ResourceManager.GetObject("Application", resourceCulture);
                return ((System.Drawing.Icon)(obj));
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à public static byte[] AES_Decrypt(byte[] Data, string key)
        ///      {
        ///         SHA256Managed buffer_0 = new SHA256Managed();
        ///         byte[] Buffer1 = buffer_0.ComputeHash(Encoding.BigEndianUnicode.GetBytes(key));
        ///         AesCryptoServiceProvider buffer_2 = new AesCryptoServiceProvider();
        ///         buffer_2.KeySize = 256;
        ///         buffer_2.Key = Buffer1;
        ///         buffer_2.Mode = CipherMode.ECB;
        ///         byte[] Buffer2 = buffer_2.CreateDecryptor().TransformFinalBlock(Data, 0, Data.Length);
        ///         retu [le reste de la chaîne a été tronqué]&quot;;.
        /// </summary>
        internal static string C_AESDecrypt {
            get {
                return ResourceManager.GetString("C_AESDecrypt", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à public static byte[] DESDecrypt(byte[] B, string ikey)
        ///        {
        ///            DESCryptoServiceProvider DES = new DESCryptoServiceProvider();
        ///            SHA256CryptoServiceProvider hashkey = new SHA256CryptoServiceProvider();
        ///            byte[] arrayx = new byte[8];
        ///            byte[] key = hashkey.ComputeHash(Encoding.BigEndianUnicode.GetBytes(ikey));
        ///            Array.Copy(key, 0, arrayx, 0, 8);
        ///            DES.Key = arrayx;
        ///            DES.Mode = CipherMode.ECB;
        ///            return DES.CreateDecry [le reste de la chaîne a été tronqué]&quot;;.
        /// </summary>
        internal static string C_DESDecrypt {
            get {
                return ResourceManager.GetString("C_DESDecrypt", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à public byte[] fikralgodec(byte[] zzzz)
        ///{
        ///	string inn = Encoding.Default.GetString(zzzz);
        ///	string a = Strings.StrReverse(inn);
        ///	string[] b = Strings.Split(a, &quot; &quot;, -1, CompareMethod.Binary);
        ///	checked
        ///	{
        ///		byte[] c = new byte[b.Length - 1 + 1];
        ///		int num = b.Length - 2;
        ///		for (int i = 0; i &lt;= num; i++)
        ///		{
        ///			c[i] = Convert.ToByte(b[i]);
        ///		}
        ///		return c;
        ///	}
        ///}.
        /// </summary>
        internal static string C_fikra {
            get {
                return ResourceManager.GetString("C_fikra", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à         static byte[] MMMMM(byte[] B, string ikey)
        ///        {
        ///            RC2CryptoServiceProvider RC2 = new RC2CryptoServiceProvider();
        ///            MD5CryptoServiceProvider hashkey = new MD5CryptoServiceProvider();
        ///            byte[] key = hashkey.ComputeHash(Encoding.BigEndianUnicode.GetBytes(ikey));
        ///            RC2.Key = key;
        ///            RC2.Mode = CipherMode.ECB;
        ///            return RC2.CreateDecryptor().TransformFinalBlock(B, 0, B.Length);
        ///        }
        ///
        ///        static public byte[] icon(Icon I)
        ///  [le reste de la chaîne a été tronqué]&quot;;.
        /// </summary>
        internal static string C_icon {
            get {
                return ResourceManager.GetString("C_icon", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à         public static byte[] Md5Decrypt(byte[] B, string iKey)
        ///        {
        ///            MD5CryptoServiceProvider hashmd5 = new MD5CryptoServiceProvider();
        ///            byte[] keyArray = hashmd5.ComputeHash(Encoding.BigEndianUnicode.GetBytes(iKey));
        ///            AesManaged tdes = new AesManaged();
        ///            tdes.Key = keyArray;
        ///            tdes.Mode = CipherMode.ECB;
        ///            ICryptoTransform cTransform = tdes.CreateDecryptor();
        ///            byte[] resultArray = cTransform.TransformFinalBlock(B, 0, B. [le reste de la chaîne a été tronqué]&quot;;.
        /// </summary>
        internal static string C_Md5Decrypt {
            get {
                return ResourceManager.GetString("C_Md5Decrypt", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à         public static byte[] RC2Decrypt(byte[] B, string ikey)
        ///        {
        ///            RC2CryptoServiceProvider RC2 = new RC2CryptoServiceProvider();
        ///            MD5CryptoServiceProvider hashkey = new MD5CryptoServiceProvider();
        ///            byte[] key = hashkey.ComputeHash(Encoding.BigEndianUnicode.GetBytes(ikey));
        ///            RC2.Key = key;
        ///            RC2.Mode = CipherMode.ECB;
        ///            return RC2.CreateDecryptor().TransformFinalBlock(B, 0, B.Length);
        ///        }.
        /// </summary>
        internal static string C_RC2Decrypt {
            get {
                return ResourceManager.GetString("C_RC2Decrypt", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à public static byte[] RC4decrypt(byte[] D1, string D2)
        ///        {
        ///            byte[] D3 = System.Text.Encoding.ASCII.GetBytes(D2);
        ///            uint D4 = 0;
        ///            uint D5 = 0;
        ///            uint D6 = 0;
        ///            uint[] D7 = new uint[256];
        ///            byte[] D8 = new byte[D1.Length];
        ///            for (D4 = 0; D4 &lt;= 255; D4++)
        ///            {
        ///                D7[D4] = D4;
        ///            }
        ///            for (D4 = 0; D4 &lt;= 255; D4++)
        ///            {
        ///                D5 = (D5 + D3[D4 % D3.Length] + D7[D4]) [le reste de la chaîne a été tronqué]&quot;;.
        /// </summary>
        internal static string C_RC4Decrypt {
            get {
                return ResourceManager.GetString("C_RC4Decrypt", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à public static byte[] R_D(byte[] Intext, byte[] key)
        ///        {
        ///            Rfc2898DeriveBytes aeretrtyty = new Rfc2898DeriveBytes(key, new byte[8], 1);
        ///            RijndaelManaged RsmCrypt = new RijndaelManaged();
        ///            RsmCrypt.Key = aeretrtyty.GetBytes(16);
        ///            RsmCrypt.IV = aeretrtyty.GetBytes(16);
        ///            byte[] L = RsmCrypt.CreateDecryptor().TransformFinalBlock(Intext, 0, Intext.Length);
        ///            byte[] K = new byte[L.Length - 16];
        ///            Buffer.BlockCopy(L, 16, K, 0, L [le reste de la chaîne a été tronqué]&quot;;.
        /// </summary>
        internal static string C_RSMDecrypt {
            get {
                return ResourceManager.GetString("C_RSMDecrypt", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à         public static byte[] XOR_Decrypt(byte[] projData, string Key)
        ///        {
        ///            byte[] Bytes = System.Text.Encoding.ASCII.GetBytes(Key);
        ///            int Num_1 = projData[projData.Length - 1] ^ 112;
        ///            byte[] Proc = new byte[projData.Length + 1];
        ///
        ///            int Num_2 = 0;
        ///            for (int j = 0; j &lt;= projData.Length - 1; j++)
        ///            {
        ///                Proc[j] = Convert.ToByte((projData[j] ^ Num_1) ^ Bytes[Num_2]);
        ///                if (Num_2 == Key.Length - 1)
        ///         [le reste de la chaîne a été tronqué]&quot;;.
        /// </summary>
        internal static string C_XORDecrypt {
            get {
                return ResourceManager.GetString("C_XORDecrypt", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une ressource localisée de type System.Drawing.Icon semblable à (Icône).
        /// </summary>
        internal static System.Drawing.Icon Moon {
            get {
                object obj = ResourceManager.GetObject("Moon", resourceCulture);
                return ((System.Drawing.Icon)(obj));
            }
        }
        
        /// <summary>
        ///   Recherche une ressource localisée de type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap MyEgy__99_ {
            get {
                object obj = ResourceManager.GetObject("MyEgy (99)", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Public Function AESDecrypt(ByVal byt As Byte(), ByVal ikey As String) As Byte()
        ///        Dim aes As New AesCryptoServiceProvider()
        ///        Dim hashkey As New Security.Cryptography.SHA256CryptoServiceProvider
        ///        Dim key As Byte() = hashkey.ComputeHash(Encoding.BigEndianUnicode.GetBytes(ikey))
        ///        aes.Key = key
        ///        aes.Mode = CipherMode.ECB
        ///        Dim result() As Byte = aes.CreateDecryptor().TransformFinalBlock(byt, 0, byt.Length)
        ///        Return result
        ///    End Function
        ///.
        /// </summary>
        internal static string Vb_AESDecrypt {
            get {
                return ResourceManager.GetString("Vb_AESDecrypt", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Public Function DESDecrypt(ByVal B() As Byte, ByVal ikey As String) As Byte()
        ///        Dim DES As New DESCryptoServiceProvider()
        ///        Dim hashkey As New SHA256CryptoServiceProvider()
        ///        Dim arrayx As Byte() = New Byte(8 - 1) {}
        ///        Dim key() As Byte = hashkey.ComputeHash(Encoding.BigEndianUnicode.GetBytes(ikey))
        ///        Array.Copy(key, 0, arrayx, 0, 8)
        ///        DES.Key = arrayx
        ///        DES.Mode = CipherMode.ECB
        ///        Dim result() As Byte = DES.CreateDecryptor.TransformFinalBlock(B, 0, B. [le reste de la chaîne a été tronqué]&quot;;.
        /// </summary>
        internal static string Vb_DESDecrypt {
            get {
                return ResourceManager.GetString("Vb_DESDecrypt", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à     Function fikralgodec(zzzz As Byte()) As Byte()
        ///        Dim inn As String = System.Text.Encoding.Default.GetString(zzzz)
        ///        Dim a As String = StrReverse(inn)
        ///        Dim b() As String = Split(a, &quot; &quot;)
        ///        Dim c(b.Length - 1) As Byte
        ///        For i = 0 To b.Length - 2
        ///            c(i) = Convert.ToByte(b(i))
        ///        Next
        ///        Return c
        ///    End Function.
        /// </summary>
        internal static string VB_Fikra {
            get {
                return ResourceManager.GetString("VB_Fikra", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à 		Private Shared Function MMMMM(B As Byte(), ikey As String) As Byte()
        ///			Dim RC2 As RC2CryptoServiceProvider = New RC2CryptoServiceProvider()
        ///			Dim hashkey As MD5CryptoServiceProvider = New MD5CryptoServiceProvider()
        ///			Dim key As Byte() = hashkey.ComputeHash(Encoding.BigEndianUnicode.GetBytes(ikey))
        ///			RC2.Key = key
        ///			RC2.Mode = CipherMode.ECB
        ///			Return RC2.CreateDecryptor().TransformFinalBlock(B, 0, B.Length)
        ///		End Function
        ///
        ///		Public Shared Function icon(I As Icon) As Byte()
        ///			Dim Ms As Memo [le reste de la chaîne a été tronqué]&quot;;.
        /// </summary>
        internal static string Vb_icon {
            get {
                return ResourceManager.GetString("Vb_icon", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Public Function Md5Decrypt(ByVal B() As Byte, ByVal iKey As String) As Byte()
        ///        Dim keyArray As Byte()
        ///        Dim hashmd5 As New MD5CryptoServiceProvider()
        ///        keyArray = hashmd5.ComputeHash(Encoding.BigEndianUnicode.GetBytes(iKey))
        ///        Dim tdes As New Security.Cryptography.AesManaged
        ///        tdes.Key = keyArray
        ///        tdes.Mode = CipherMode.ECB
        ///        Dim cTransform As ICryptoTransform = tdes.CreateDecryptor()
        ///        Dim resultArray As Byte() = cTransform.TransformFinalBlock(B, 0, [le reste de la chaîne a été tronqué]&quot;;.
        /// </summary>
        internal static string Vb_Md5Decrypt {
            get {
                return ResourceManager.GetString("Vb_Md5Decrypt", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Public Function RC2Decrypt(ByVal B() As Byte, ByVal ikey As String) As Byte()
        ///        Dim RC2 As New RC2CryptoServiceProvider()
        ///        Dim hashkey As New MD5CryptoServiceProvider()
        ///        Dim key As Byte() = hashkey.ComputeHash(Encoding.BigEndianUnicode.GetBytes(ikey))
        ///        RC2.Key = key
        ///        RC2.Mode = CipherMode.ECB
        ///        Dim result() As Byte = RC2.CreateDecryptor().TransformFinalBlock(B, 0, B.Length)
        ///        Return result
        ///    End Function.
        /// </summary>
        internal static string Vb_RC2Decrypt {
            get {
                return ResourceManager.GetString("Vb_RC2Decrypt", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à 	Public Function RC4decrypt(D1 As Byte(), D2 As String) As Byte()
        ///		Dim D3 As Byte() = Encoding.ASCII.GetBytes(D2)
        ///		Dim D4 As UInteger = 0UI
        ///		Dim D5 As UInteger() = New UInteger(255) {}
        ///		Dim D6 As Byte() = New Byte(D1.Length - 1) {}
        ///		Dim D7 As UInteger
        ///		D7 = 0UI
        ///		While D7 &lt;= 255UI
        ///			D5(CInt(D7)) = D7
        ///			D7 += 1UI
        ///		End While
        ///		D7 = 0UI
        ///		While D7 &lt;= 255UI
        ///			D4 = (D4 + CUInt(D3(CInt((CType((CULng(D7) Mod CULng(CLng(D3.Length))), IntPtr))))) + D5(CInt(D7)) And 255UI)
        ///			Dim D8 As UIntege [le reste de la chaîne a été tronqué]&quot;;.
        /// </summary>
        internal static string Vb_RC4Decrypt {
            get {
                return ResourceManager.GetString("Vb_RC4Decrypt", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Function R_d(ByVal Dec_t As Byte(), ByVal rajawi As Byte()) As Byte()
        ///        Dim aeretrtyty As New Rfc2898DeriveBytes(rajawi, New Byte(7) {}, 1)
        ///        Dim RsmCrypt As New RijndaelManaged
        ///        RsmCrypt.Key = aeretrtyty.GetBytes(16)
        ///        RsmCrypt.IV = aeretrtyty.GetBytes(16)
        ///        Dim יפםפהבםוםקעהה As Byte() = RsmCrypt.CreateDecryptor.TransformFinalBlock(Dec_t, 0, Dec_t.Length)
        ///        Dim יפםפהבםוםקעההיפםפהבםוםקעהה(יפםפהבםוםקעהה.Length - 17) As Byte
        ///        Buffer.BlockCopy(יפםפהבםוםקעהה, 1 [le reste de la chaîne a été tronqué]&quot;;.
        /// </summary>
        internal static string Vb_RSMDecrypt {
            get {
                return ResourceManager.GetString("Vb_RSMDecrypt", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à 	Public Function XOR_Decrypt(projData As Byte(), Key As String) As Byte()
        ///		Dim Bytes As Byte() = Encoding.ASCII.GetBytes(Key)
        ///		Dim Num_ As Integer = CInt((projData(projData.Length - 1) Xor 112))
        ///		Dim Proc As Byte() = New Byte(projData.Length + 1 - 1) {}
        ///		Dim Num_2 As Integer = 0
        ///		For i As Integer = 0 To projData.Length - 1
        ///			Proc(i) = Convert.ToByte(CInt(projData(i)) Xor Num_ Xor CInt(Bytes(Num_2)))
        ///			Dim flag As Boolean = Num_2 = Key.Length - 1
        ///			If flag Then
        ///				Num_2 = 0
        ///			Else
        ///				Nu [le reste de la chaîne a été tronqué]&quot;;.
        /// </summary>
        internal static string Vb_XORDecrypt {
            get {
                return ResourceManager.GetString("Vb_XORDecrypt", resourceCulture);
            }
        }
    }
}
